// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'Transaction_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$TransactionState {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionState);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionState()';
}


}

/// @nodoc
class $TransactionStateCopyWith<$Res>  {
$TransactionStateCopyWith(TransactionState _, $Res Function(TransactionState) __);
}


/// Adds pattern-matching-related methods to [TransactionState].
extension TransactionStatePatterns on TransactionState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( Initial value)?  initial,TResult Function( LoadingpaymentInitiation value)?  loadinpaymentinitiation,TResult Function( PaymentInitiationSuccessfull value)?  paymentinitiationSuccessfull,TResult Function( PaymentInitiationFailed value)?  paymentinitiationFailed,TResult Function( LoadingtoSendMoney value)?  loadingtosendmoney,TResult Function( SendMoneySuccessfully value)?  sendMoneySuccessfully,TResult Function( SendMoneyFailed value)?  sendMoneyFailed,TResult Function( LodingAccessTokem value)?  momopaymentaccesstokenloading,TResult Function( MomoPaymentAccessTokenLoadingSuccessfull value)?  momopaymentaccesstokenloadingsuccessfull,TResult Function( MomoPaymentAccessTokenLoadingFailed value)?  momopaymentaccesstokenloadingfailed,required TResult orElse(),}){
final _that = this;
switch (_that) {
case Initial() when initial != null:
return initial(_that);case LoadingpaymentInitiation() when loadinpaymentinitiation != null:
return loadinpaymentinitiation(_that);case PaymentInitiationSuccessfull() when paymentinitiationSuccessfull != null:
return paymentinitiationSuccessfull(_that);case PaymentInitiationFailed() when paymentinitiationFailed != null:
return paymentinitiationFailed(_that);case LoadingtoSendMoney() when loadingtosendmoney != null:
return loadingtosendmoney(_that);case SendMoneySuccessfully() when sendMoneySuccessfully != null:
return sendMoneySuccessfully(_that);case SendMoneyFailed() when sendMoneyFailed != null:
return sendMoneyFailed(_that);case LodingAccessTokem() when momopaymentaccesstokenloading != null:
return momopaymentaccesstokenloading(_that);case MomoPaymentAccessTokenLoadingSuccessfull() when momopaymentaccesstokenloadingsuccessfull != null:
return momopaymentaccesstokenloadingsuccessfull(_that);case MomoPaymentAccessTokenLoadingFailed() when momopaymentaccesstokenloadingfailed != null:
return momopaymentaccesstokenloadingfailed(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( Initial value)  initial,required TResult Function( LoadingpaymentInitiation value)  loadinpaymentinitiation,required TResult Function( PaymentInitiationSuccessfull value)  paymentinitiationSuccessfull,required TResult Function( PaymentInitiationFailed value)  paymentinitiationFailed,required TResult Function( LoadingtoSendMoney value)  loadingtosendmoney,required TResult Function( SendMoneySuccessfully value)  sendMoneySuccessfully,required TResult Function( SendMoneyFailed value)  sendMoneyFailed,required TResult Function( LodingAccessTokem value)  momopaymentaccesstokenloading,required TResult Function( MomoPaymentAccessTokenLoadingSuccessfull value)  momopaymentaccesstokenloadingsuccessfull,required TResult Function( MomoPaymentAccessTokenLoadingFailed value)  momopaymentaccesstokenloadingfailed,}){
final _that = this;
switch (_that) {
case Initial():
return initial(_that);case LoadingpaymentInitiation():
return loadinpaymentinitiation(_that);case PaymentInitiationSuccessfull():
return paymentinitiationSuccessfull(_that);case PaymentInitiationFailed():
return paymentinitiationFailed(_that);case LoadingtoSendMoney():
return loadingtosendmoney(_that);case SendMoneySuccessfully():
return sendMoneySuccessfully(_that);case SendMoneyFailed():
return sendMoneyFailed(_that);case LodingAccessTokem():
return momopaymentaccesstokenloading(_that);case MomoPaymentAccessTokenLoadingSuccessfull():
return momopaymentaccesstokenloadingsuccessfull(_that);case MomoPaymentAccessTokenLoadingFailed():
return momopaymentaccesstokenloadingfailed(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( Initial value)?  initial,TResult? Function( LoadingpaymentInitiation value)?  loadinpaymentinitiation,TResult? Function( PaymentInitiationSuccessfull value)?  paymentinitiationSuccessfull,TResult? Function( PaymentInitiationFailed value)?  paymentinitiationFailed,TResult? Function( LoadingtoSendMoney value)?  loadingtosendmoney,TResult? Function( SendMoneySuccessfully value)?  sendMoneySuccessfully,TResult? Function( SendMoneyFailed value)?  sendMoneyFailed,TResult? Function( LodingAccessTokem value)?  momopaymentaccesstokenloading,TResult? Function( MomoPaymentAccessTokenLoadingSuccessfull value)?  momopaymentaccesstokenloadingsuccessfull,TResult? Function( MomoPaymentAccessTokenLoadingFailed value)?  momopaymentaccesstokenloadingfailed,}){
final _that = this;
switch (_that) {
case Initial() when initial != null:
return initial(_that);case LoadingpaymentInitiation() when loadinpaymentinitiation != null:
return loadinpaymentinitiation(_that);case PaymentInitiationSuccessfull() when paymentinitiationSuccessfull != null:
return paymentinitiationSuccessfull(_that);case PaymentInitiationFailed() when paymentinitiationFailed != null:
return paymentinitiationFailed(_that);case LoadingtoSendMoney() when loadingtosendmoney != null:
return loadingtosendmoney(_that);case SendMoneySuccessfully() when sendMoneySuccessfully != null:
return sendMoneySuccessfully(_that);case SendMoneyFailed() when sendMoneyFailed != null:
return sendMoneyFailed(_that);case LodingAccessTokem() when momopaymentaccesstokenloading != null:
return momopaymentaccesstokenloading(_that);case MomoPaymentAccessTokenLoadingSuccessfull() when momopaymentaccesstokenloadingsuccessfull != null:
return momopaymentaccesstokenloadingsuccessfull(_that);case MomoPaymentAccessTokenLoadingFailed() when momopaymentaccesstokenloadingfailed != null:
return momopaymentaccesstokenloadingfailed(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  initial,TResult Function()?  loadinpaymentinitiation,TResult Function( AppResponse<Map<String, dynamic>> response)?  paymentinitiationSuccessfull,TResult Function( String errormessga)?  paymentinitiationFailed,TResult Function()?  loadingtosendmoney,TResult Function( AppResponse<Map<String, dynamic>> response)?  sendMoneySuccessfully,TResult Function( String errromessage)?  sendMoneyFailed,TResult Function()?  momopaymentaccesstokenloading,TResult Function( AppResponse<Map<String, dynamic>> response)?  momopaymentaccesstokenloadingsuccessfull,TResult Function( String errormessga)?  momopaymentaccesstokenloadingfailed,required TResult orElse(),}) {final _that = this;
switch (_that) {
case Initial() when initial != null:
return initial();case LoadingpaymentInitiation() when loadinpaymentinitiation != null:
return loadinpaymentinitiation();case PaymentInitiationSuccessfull() when paymentinitiationSuccessfull != null:
return paymentinitiationSuccessfull(_that.response);case PaymentInitiationFailed() when paymentinitiationFailed != null:
return paymentinitiationFailed(_that.errormessga);case LoadingtoSendMoney() when loadingtosendmoney != null:
return loadingtosendmoney();case SendMoneySuccessfully() when sendMoneySuccessfully != null:
return sendMoneySuccessfully(_that.response);case SendMoneyFailed() when sendMoneyFailed != null:
return sendMoneyFailed(_that.errromessage);case LodingAccessTokem() when momopaymentaccesstokenloading != null:
return momopaymentaccesstokenloading();case MomoPaymentAccessTokenLoadingSuccessfull() when momopaymentaccesstokenloadingsuccessfull != null:
return momopaymentaccesstokenloadingsuccessfull(_that.response);case MomoPaymentAccessTokenLoadingFailed() when momopaymentaccesstokenloadingfailed != null:
return momopaymentaccesstokenloadingfailed(_that.errormessga);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  initial,required TResult Function()  loadinpaymentinitiation,required TResult Function( AppResponse<Map<String, dynamic>> response)  paymentinitiationSuccessfull,required TResult Function( String errormessga)  paymentinitiationFailed,required TResult Function()  loadingtosendmoney,required TResult Function( AppResponse<Map<String, dynamic>> response)  sendMoneySuccessfully,required TResult Function( String errromessage)  sendMoneyFailed,required TResult Function()  momopaymentaccesstokenloading,required TResult Function( AppResponse<Map<String, dynamic>> response)  momopaymentaccesstokenloadingsuccessfull,required TResult Function( String errormessga)  momopaymentaccesstokenloadingfailed,}) {final _that = this;
switch (_that) {
case Initial():
return initial();case LoadingpaymentInitiation():
return loadinpaymentinitiation();case PaymentInitiationSuccessfull():
return paymentinitiationSuccessfull(_that.response);case PaymentInitiationFailed():
return paymentinitiationFailed(_that.errormessga);case LoadingtoSendMoney():
return loadingtosendmoney();case SendMoneySuccessfully():
return sendMoneySuccessfully(_that.response);case SendMoneyFailed():
return sendMoneyFailed(_that.errromessage);case LodingAccessTokem():
return momopaymentaccesstokenloading();case MomoPaymentAccessTokenLoadingSuccessfull():
return momopaymentaccesstokenloadingsuccessfull(_that.response);case MomoPaymentAccessTokenLoadingFailed():
return momopaymentaccesstokenloadingfailed(_that.errormessga);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  initial,TResult? Function()?  loadinpaymentinitiation,TResult? Function( AppResponse<Map<String, dynamic>> response)?  paymentinitiationSuccessfull,TResult? Function( String errormessga)?  paymentinitiationFailed,TResult? Function()?  loadingtosendmoney,TResult? Function( AppResponse<Map<String, dynamic>> response)?  sendMoneySuccessfully,TResult? Function( String errromessage)?  sendMoneyFailed,TResult? Function()?  momopaymentaccesstokenloading,TResult? Function( AppResponse<Map<String, dynamic>> response)?  momopaymentaccesstokenloadingsuccessfull,TResult? Function( String errormessga)?  momopaymentaccesstokenloadingfailed,}) {final _that = this;
switch (_that) {
case Initial() when initial != null:
return initial();case LoadingpaymentInitiation() when loadinpaymentinitiation != null:
return loadinpaymentinitiation();case PaymentInitiationSuccessfull() when paymentinitiationSuccessfull != null:
return paymentinitiationSuccessfull(_that.response);case PaymentInitiationFailed() when paymentinitiationFailed != null:
return paymentinitiationFailed(_that.errormessga);case LoadingtoSendMoney() when loadingtosendmoney != null:
return loadingtosendmoney();case SendMoneySuccessfully() when sendMoneySuccessfully != null:
return sendMoneySuccessfully(_that.response);case SendMoneyFailed() when sendMoneyFailed != null:
return sendMoneyFailed(_that.errromessage);case LodingAccessTokem() when momopaymentaccesstokenloading != null:
return momopaymentaccesstokenloading();case MomoPaymentAccessTokenLoadingSuccessfull() when momopaymentaccesstokenloadingsuccessfull != null:
return momopaymentaccesstokenloadingsuccessfull(_that.response);case MomoPaymentAccessTokenLoadingFailed() when momopaymentaccesstokenloadingfailed != null:
return momopaymentaccesstokenloadingfailed(_that.errormessga);case _:
  return null;

}
}

}

/// @nodoc


class Initial implements TransactionState {
  const Initial();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Initial);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionState.initial()';
}


}




/// @nodoc


class LoadingpaymentInitiation implements TransactionState {
  const LoadingpaymentInitiation();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoadingpaymentInitiation);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionState.loadinpaymentinitiation()';
}


}




/// @nodoc


class PaymentInitiationSuccessfull implements TransactionState {
  const PaymentInitiationSuccessfull({required this.response});
  

 final  AppResponse<Map<String, dynamic>> response;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PaymentInitiationSuccessfullCopyWith<PaymentInitiationSuccessfull> get copyWith => _$PaymentInitiationSuccessfullCopyWithImpl<PaymentInitiationSuccessfull>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PaymentInitiationSuccessfull&&(identical(other.response, response) || other.response == response));
}


@override
int get hashCode => Object.hash(runtimeType,response);

@override
String toString() {
  return 'TransactionState.paymentinitiationSuccessfull(response: $response)';
}


}

/// @nodoc
abstract mixin class $PaymentInitiationSuccessfullCopyWith<$Res> implements $TransactionStateCopyWith<$Res> {
  factory $PaymentInitiationSuccessfullCopyWith(PaymentInitiationSuccessfull value, $Res Function(PaymentInitiationSuccessfull) _then) = _$PaymentInitiationSuccessfullCopyWithImpl;
@useResult
$Res call({
 AppResponse<Map<String, dynamic>> response
});




}
/// @nodoc
class _$PaymentInitiationSuccessfullCopyWithImpl<$Res>
    implements $PaymentInitiationSuccessfullCopyWith<$Res> {
  _$PaymentInitiationSuccessfullCopyWithImpl(this._self, this._then);

  final PaymentInitiationSuccessfull _self;
  final $Res Function(PaymentInitiationSuccessfull) _then;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? response = null,}) {
  return _then(PaymentInitiationSuccessfull(
response: null == response ? _self.response : response // ignore: cast_nullable_to_non_nullable
as AppResponse<Map<String, dynamic>>,
  ));
}


}

/// @nodoc


class PaymentInitiationFailed implements TransactionState {
  const PaymentInitiationFailed({required this.errormessga});
  

 final  String errormessga;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PaymentInitiationFailedCopyWith<PaymentInitiationFailed> get copyWith => _$PaymentInitiationFailedCopyWithImpl<PaymentInitiationFailed>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PaymentInitiationFailed&&(identical(other.errormessga, errormessga) || other.errormessga == errormessga));
}


@override
int get hashCode => Object.hash(runtimeType,errormessga);

@override
String toString() {
  return 'TransactionState.paymentinitiationFailed(errormessga: $errormessga)';
}


}

/// @nodoc
abstract mixin class $PaymentInitiationFailedCopyWith<$Res> implements $TransactionStateCopyWith<$Res> {
  factory $PaymentInitiationFailedCopyWith(PaymentInitiationFailed value, $Res Function(PaymentInitiationFailed) _then) = _$PaymentInitiationFailedCopyWithImpl;
@useResult
$Res call({
 String errormessga
});




}
/// @nodoc
class _$PaymentInitiationFailedCopyWithImpl<$Res>
    implements $PaymentInitiationFailedCopyWith<$Res> {
  _$PaymentInitiationFailedCopyWithImpl(this._self, this._then);

  final PaymentInitiationFailed _self;
  final $Res Function(PaymentInitiationFailed) _then;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? errormessga = null,}) {
  return _then(PaymentInitiationFailed(
errormessga: null == errormessga ? _self.errormessga : errormessga // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LoadingtoSendMoney implements TransactionState {
  const LoadingtoSendMoney();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LoadingtoSendMoney);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionState.loadingtosendmoney()';
}


}




/// @nodoc


class SendMoneySuccessfully implements TransactionState {
  const SendMoneySuccessfully({required this.response});
  

 final  AppResponse<Map<String, dynamic>> response;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SendMoneySuccessfullyCopyWith<SendMoneySuccessfully> get copyWith => _$SendMoneySuccessfullyCopyWithImpl<SendMoneySuccessfully>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SendMoneySuccessfully&&(identical(other.response, response) || other.response == response));
}


@override
int get hashCode => Object.hash(runtimeType,response);

@override
String toString() {
  return 'TransactionState.sendMoneySuccessfully(response: $response)';
}


}

/// @nodoc
abstract mixin class $SendMoneySuccessfullyCopyWith<$Res> implements $TransactionStateCopyWith<$Res> {
  factory $SendMoneySuccessfullyCopyWith(SendMoneySuccessfully value, $Res Function(SendMoneySuccessfully) _then) = _$SendMoneySuccessfullyCopyWithImpl;
@useResult
$Res call({
 AppResponse<Map<String, dynamic>> response
});




}
/// @nodoc
class _$SendMoneySuccessfullyCopyWithImpl<$Res>
    implements $SendMoneySuccessfullyCopyWith<$Res> {
  _$SendMoneySuccessfullyCopyWithImpl(this._self, this._then);

  final SendMoneySuccessfully _self;
  final $Res Function(SendMoneySuccessfully) _then;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? response = null,}) {
  return _then(SendMoneySuccessfully(
response: null == response ? _self.response : response // ignore: cast_nullable_to_non_nullable
as AppResponse<Map<String, dynamic>>,
  ));
}


}

/// @nodoc


class SendMoneyFailed implements TransactionState {
  const SendMoneyFailed({required this.errromessage});
  

 final  String errromessage;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SendMoneyFailedCopyWith<SendMoneyFailed> get copyWith => _$SendMoneyFailedCopyWithImpl<SendMoneyFailed>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SendMoneyFailed&&(identical(other.errromessage, errromessage) || other.errromessage == errromessage));
}


@override
int get hashCode => Object.hash(runtimeType,errromessage);

@override
String toString() {
  return 'TransactionState.sendMoneyFailed(errromessage: $errromessage)';
}


}

/// @nodoc
abstract mixin class $SendMoneyFailedCopyWith<$Res> implements $TransactionStateCopyWith<$Res> {
  factory $SendMoneyFailedCopyWith(SendMoneyFailed value, $Res Function(SendMoneyFailed) _then) = _$SendMoneyFailedCopyWithImpl;
@useResult
$Res call({
 String errromessage
});




}
/// @nodoc
class _$SendMoneyFailedCopyWithImpl<$Res>
    implements $SendMoneyFailedCopyWith<$Res> {
  _$SendMoneyFailedCopyWithImpl(this._self, this._then);

  final SendMoneyFailed _self;
  final $Res Function(SendMoneyFailed) _then;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? errromessage = null,}) {
  return _then(SendMoneyFailed(
errromessage: null == errromessage ? _self.errromessage : errromessage // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class LodingAccessTokem implements TransactionState {
  const LodingAccessTokem();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LodingAccessTokem);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionState.momopaymentaccesstokenloading()';
}


}




/// @nodoc


class MomoPaymentAccessTokenLoadingSuccessfull implements TransactionState {
  const MomoPaymentAccessTokenLoadingSuccessfull({required this.response});
  

 final  AppResponse<Map<String, dynamic>> response;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MomoPaymentAccessTokenLoadingSuccessfullCopyWith<MomoPaymentAccessTokenLoadingSuccessfull> get copyWith => _$MomoPaymentAccessTokenLoadingSuccessfullCopyWithImpl<MomoPaymentAccessTokenLoadingSuccessfull>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MomoPaymentAccessTokenLoadingSuccessfull&&(identical(other.response, response) || other.response == response));
}


@override
int get hashCode => Object.hash(runtimeType,response);

@override
String toString() {
  return 'TransactionState.momopaymentaccesstokenloadingsuccessfull(response: $response)';
}


}

/// @nodoc
abstract mixin class $MomoPaymentAccessTokenLoadingSuccessfullCopyWith<$Res> implements $TransactionStateCopyWith<$Res> {
  factory $MomoPaymentAccessTokenLoadingSuccessfullCopyWith(MomoPaymentAccessTokenLoadingSuccessfull value, $Res Function(MomoPaymentAccessTokenLoadingSuccessfull) _then) = _$MomoPaymentAccessTokenLoadingSuccessfullCopyWithImpl;
@useResult
$Res call({
 AppResponse<Map<String, dynamic>> response
});




}
/// @nodoc
class _$MomoPaymentAccessTokenLoadingSuccessfullCopyWithImpl<$Res>
    implements $MomoPaymentAccessTokenLoadingSuccessfullCopyWith<$Res> {
  _$MomoPaymentAccessTokenLoadingSuccessfullCopyWithImpl(this._self, this._then);

  final MomoPaymentAccessTokenLoadingSuccessfull _self;
  final $Res Function(MomoPaymentAccessTokenLoadingSuccessfull) _then;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? response = null,}) {
  return _then(MomoPaymentAccessTokenLoadingSuccessfull(
response: null == response ? _self.response : response // ignore: cast_nullable_to_non_nullable
as AppResponse<Map<String, dynamic>>,
  ));
}


}

/// @nodoc


class MomoPaymentAccessTokenLoadingFailed implements TransactionState {
  const MomoPaymentAccessTokenLoadingFailed({required this.errormessga});
  

 final  String errormessga;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MomoPaymentAccessTokenLoadingFailedCopyWith<MomoPaymentAccessTokenLoadingFailed> get copyWith => _$MomoPaymentAccessTokenLoadingFailedCopyWithImpl<MomoPaymentAccessTokenLoadingFailed>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MomoPaymentAccessTokenLoadingFailed&&(identical(other.errormessga, errormessga) || other.errormessga == errormessga));
}


@override
int get hashCode => Object.hash(runtimeType,errormessga);

@override
String toString() {
  return 'TransactionState.momopaymentaccesstokenloadingfailed(errormessga: $errormessga)';
}


}

/// @nodoc
abstract mixin class $MomoPaymentAccessTokenLoadingFailedCopyWith<$Res> implements $TransactionStateCopyWith<$Res> {
  factory $MomoPaymentAccessTokenLoadingFailedCopyWith(MomoPaymentAccessTokenLoadingFailed value, $Res Function(MomoPaymentAccessTokenLoadingFailed) _then) = _$MomoPaymentAccessTokenLoadingFailedCopyWithImpl;
@useResult
$Res call({
 String errormessga
});




}
/// @nodoc
class _$MomoPaymentAccessTokenLoadingFailedCopyWithImpl<$Res>
    implements $MomoPaymentAccessTokenLoadingFailedCopyWith<$Res> {
  _$MomoPaymentAccessTokenLoadingFailedCopyWithImpl(this._self, this._then);

  final MomoPaymentAccessTokenLoadingFailed _self;
  final $Res Function(MomoPaymentAccessTokenLoadingFailed) _then;

/// Create a copy of TransactionState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? errormessga = null,}) {
  return _then(MomoPaymentAccessTokenLoadingFailed(
errormessga: null == errormessga ? _self.errormessga : errormessga // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc
mixin _$TransactionEvent {





@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TransactionEvent);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionEvent()';
}


}

/// @nodoc
class $TransactionEventCopyWith<$Res>  {
$TransactionEventCopyWith(TransactionEvent _, $Res Function(TransactionEvent) __);
}


/// Adds pattern-matching-related methods to [TransactionEvent].
extension TransactionEventPatterns on TransactionEvent {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( InitiatTransaction value)?  transactionInitiation,TResult Function( Reset value)?  reset,TResult Function( SendMoneyToAnotherAccount value)?  sendMoney,TResult Function( MomoAccessToken value)?  momoaccesstoken,required TResult orElse(),}){
final _that = this;
switch (_that) {
case InitiatTransaction() when transactionInitiation != null:
return transactionInitiation(_that);case Reset() when reset != null:
return reset(_that);case SendMoneyToAnotherAccount() when sendMoney != null:
return sendMoney(_that);case MomoAccessToken() when momoaccesstoken != null:
return momoaccesstoken(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( InitiatTransaction value)  transactionInitiation,required TResult Function( Reset value)  reset,required TResult Function( SendMoneyToAnotherAccount value)  sendMoney,required TResult Function( MomoAccessToken value)  momoaccesstoken,}){
final _that = this;
switch (_that) {
case InitiatTransaction():
return transactionInitiation(_that);case Reset():
return reset(_that);case SendMoneyToAnotherAccount():
return sendMoney(_that);case MomoAccessToken():
return momoaccesstoken(_that);}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( InitiatTransaction value)?  transactionInitiation,TResult? Function( Reset value)?  reset,TResult? Function( SendMoneyToAnotherAccount value)?  sendMoney,TResult? Function( MomoAccessToken value)?  momoaccesstoken,}){
final _that = this;
switch (_that) {
case InitiatTransaction() when transactionInitiation != null:
return transactionInitiation(_that);case Reset() when reset != null:
return reset(_that);case SendMoneyToAnotherAccount() when sendMoney != null:
return sendMoney(_that);case MomoAccessToken() when momoaccesstoken != null:
return momoaccesstoken(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function( Transaction transaction)?  transactionInitiation,TResult Function()?  reset,TResult Function( SendMoney sendmoney)?  sendMoney,TResult Function()?  momoaccesstoken,required TResult orElse(),}) {final _that = this;
switch (_that) {
case InitiatTransaction() when transactionInitiation != null:
return transactionInitiation(_that.transaction);case Reset() when reset != null:
return reset();case SendMoneyToAnotherAccount() when sendMoney != null:
return sendMoney(_that.sendmoney);case MomoAccessToken() when momoaccesstoken != null:
return momoaccesstoken();case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function( Transaction transaction)  transactionInitiation,required TResult Function()  reset,required TResult Function( SendMoney sendmoney)  sendMoney,required TResult Function()  momoaccesstoken,}) {final _that = this;
switch (_that) {
case InitiatTransaction():
return transactionInitiation(_that.transaction);case Reset():
return reset();case SendMoneyToAnotherAccount():
return sendMoney(_that.sendmoney);case MomoAccessToken():
return momoaccesstoken();}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function( Transaction transaction)?  transactionInitiation,TResult? Function()?  reset,TResult? Function( SendMoney sendmoney)?  sendMoney,TResult? Function()?  momoaccesstoken,}) {final _that = this;
switch (_that) {
case InitiatTransaction() when transactionInitiation != null:
return transactionInitiation(_that.transaction);case Reset() when reset != null:
return reset();case SendMoneyToAnotherAccount() when sendMoney != null:
return sendMoney(_that.sendmoney);case MomoAccessToken() when momoaccesstoken != null:
return momoaccesstoken();case _:
  return null;

}
}

}

/// @nodoc


class InitiatTransaction implements TransactionEvent {
  const InitiatTransaction({required this.transaction});
  

 final  Transaction transaction;

/// Create a copy of TransactionEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InitiatTransactionCopyWith<InitiatTransaction> get copyWith => _$InitiatTransactionCopyWithImpl<InitiatTransaction>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitiatTransaction&&(identical(other.transaction, transaction) || other.transaction == transaction));
}


@override
int get hashCode => Object.hash(runtimeType,transaction);

@override
String toString() {
  return 'TransactionEvent.transactionInitiation(transaction: $transaction)';
}


}

/// @nodoc
abstract mixin class $InitiatTransactionCopyWith<$Res> implements $TransactionEventCopyWith<$Res> {
  factory $InitiatTransactionCopyWith(InitiatTransaction value, $Res Function(InitiatTransaction) _then) = _$InitiatTransactionCopyWithImpl;
@useResult
$Res call({
 Transaction transaction
});


$TransactionCopyWith<$Res> get transaction;

}
/// @nodoc
class _$InitiatTransactionCopyWithImpl<$Res>
    implements $InitiatTransactionCopyWith<$Res> {
  _$InitiatTransactionCopyWithImpl(this._self, this._then);

  final InitiatTransaction _self;
  final $Res Function(InitiatTransaction) _then;

/// Create a copy of TransactionEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? transaction = null,}) {
  return _then(InitiatTransaction(
transaction: null == transaction ? _self.transaction : transaction // ignore: cast_nullable_to_non_nullable
as Transaction,
  ));
}

/// Create a copy of TransactionEvent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TransactionCopyWith<$Res> get transaction {
  
  return $TransactionCopyWith<$Res>(_self.transaction, (value) {
    return _then(_self.copyWith(transaction: value));
  });
}
}

/// @nodoc


class Reset implements TransactionEvent {
  const Reset();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Reset);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionEvent.reset()';
}


}




/// @nodoc


class SendMoneyToAnotherAccount implements TransactionEvent {
  const SendMoneyToAnotherAccount({required this.sendmoney});
  

 final  SendMoney sendmoney;

/// Create a copy of TransactionEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SendMoneyToAnotherAccountCopyWith<SendMoneyToAnotherAccount> get copyWith => _$SendMoneyToAnotherAccountCopyWithImpl<SendMoneyToAnotherAccount>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SendMoneyToAnotherAccount&&(identical(other.sendmoney, sendmoney) || other.sendmoney == sendmoney));
}


@override
int get hashCode => Object.hash(runtimeType,sendmoney);

@override
String toString() {
  return 'TransactionEvent.sendMoney(sendmoney: $sendmoney)';
}


}

/// @nodoc
abstract mixin class $SendMoneyToAnotherAccountCopyWith<$Res> implements $TransactionEventCopyWith<$Res> {
  factory $SendMoneyToAnotherAccountCopyWith(SendMoneyToAnotherAccount value, $Res Function(SendMoneyToAnotherAccount) _then) = _$SendMoneyToAnotherAccountCopyWithImpl;
@useResult
$Res call({
 SendMoney sendmoney
});


$SendMoneyCopyWith<$Res> get sendmoney;

}
/// @nodoc
class _$SendMoneyToAnotherAccountCopyWithImpl<$Res>
    implements $SendMoneyToAnotherAccountCopyWith<$Res> {
  _$SendMoneyToAnotherAccountCopyWithImpl(this._self, this._then);

  final SendMoneyToAnotherAccount _self;
  final $Res Function(SendMoneyToAnotherAccount) _then;

/// Create a copy of TransactionEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') $Res call({Object? sendmoney = null,}) {
  return _then(SendMoneyToAnotherAccount(
sendmoney: null == sendmoney ? _self.sendmoney : sendmoney // ignore: cast_nullable_to_non_nullable
as SendMoney,
  ));
}

/// Create a copy of TransactionEvent
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SendMoneyCopyWith<$Res> get sendmoney {
  
  return $SendMoneyCopyWith<$Res>(_self.sendmoney, (value) {
    return _then(_self.copyWith(sendmoney: value));
  });
}
}

/// @nodoc


class MomoAccessToken implements TransactionEvent {
  const MomoAccessToken();
  






@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MomoAccessToken);
}


@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'TransactionEvent.momoaccesstoken()';
}


}




// dart format on
